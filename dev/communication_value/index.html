<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CV Optimizations · CVChannel.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ChitambarLab.github.io/CVChannel.jl/communication_value/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CVChannel.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">CV Background</a></li><li class="is-active"><a class="tocitem" href>CV Optimizations</a><ul class="internal"><li><a class="tocitem" href="#PPT-Relaxation-of-the-CV"><span>PPT Relaxation of the CV</span></a></li><li><a class="tocitem" href="#See-Saw-Optimization-of-the-CV"><span>See-Saw Optimization of the CV</span></a></li><li><a class="tocitem" href="#Entanglement-Assisted-CV"><span>Entanglement Assisted CV</span></a></li><li><a class="tocitem" href="#CV-through-DPS-Hierarchy"><span>CV through DPS Hierarchy</span></a></li></ul></li><li><a class="tocitem" href="../cv_multiplicativity/">CV Multiplicativity</a></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="../channel_states/">Channels, States, and Operations</a></li><li><a class="tocitem" href="../optimizer_interface/">Optimization Backends</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>CV Optimizations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CV Optimizations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChitambarLab/CVChannel.jl/blob/master/docs/src/communication_value.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CV-Optimizations"><a class="docs-heading-anchor" href="#CV-Optimizations">CV Optimizations</a><a id="CV-Optimizations-1"></a><a class="docs-heading-anchor-permalink" href="#CV-Optimizations" title="Permalink"></a></h1><h2 id="PPT-Relaxation-of-the-CV"><a class="docs-heading-anchor" href="#PPT-Relaxation-of-the-CV">PPT Relaxation of the CV</a><a id="PPT-Relaxation-of-the-CV-1"></a><a class="docs-heading-anchor-permalink" href="#PPT-Relaxation-of-the-CV" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CVChannel.pptCV" href="#CVChannel.pptCV"><code>CVChannel.pptCV</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pptCV( channel :: Choi, method :: Symbol = :primal )</code></pre><p>Numerically evaluates the positive partial transpose (PPT) relaxation of the communication value for the given <a href="../channel_states/#CVChannel.Choi"><code>Choi</code></a> operator representation of a quantum channel. This optimization problem is expressed as,</p><p class="math-container">\[\begin{aligned}
    \text{pptCV}(\mathcal{N}) &amp;=  \max_{\Omega^{AB}} \text{Tr}[\Omega^{AB}J_{\mathcal{N}}] \\
    \hspace{1cm}
    &amp; \text{s.t.} \quad \text{Tr}_A[\Omega^{AB}] = \mathbb{I}^B; \\
    \hspace{1cm}
    &amp; \qquad \Omega^{AB} \in \text{PPT}(A\;:\;B),
\end{aligned}\]</p><p>where <span>$\text{PPT}(A \;:\; B)$</span> indicates the cone of matrices with a positve partial transpose. The <span>$\text{PPT}(A\;:\;B)$</span> cone contains the <span>$\text{SEP}(A\;:\;B)$</span> cone therfore, the <span>$\text{pptCV}$</span> is an upper bound for the <span>$\text{cv}$</span></p><p class="math-container">\[\text{cv}(\mathcal{N}) \leq \text{pptCV}(\mathcal{N}),\]</p><p>where equality is found for the channels whose separable cone is the same as their PPT cone.</p><p>The <code>method</code> parameter accepts the values:</p><ul><li><code>:primal</code> - Solves the primal problem (see <a href="#CVChannel.pptCVPrimal"><code>pptCVPrimal</code></a>).</li><li><code>:dual</code> - Solves the dual problem (see <a href="#CVChannel.pptCVDual"><code>pptCVDual</code></a>).</li></ul><p><strong>Returns</strong></p><p>A Tuple containing <code>(max_cv, optimizers...)</code> where <code>max_cv</code> is the communication value and optimizers is the optimal value for each of the optimization paraameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/CVChannel.jl/blob/479fa1e70d19b5434137f9017d99830796802d87/src/optimizations.jl#LL95-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.pptCVPrimal" href="#CVChannel.pptCVPrimal"><code>CVChannel.pptCVPrimal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pptCVPrimal(
    ρ :: Matrix{&lt;:Number},
    dimA :: Int,
    dimB :: Int
) :: Tuple{Float64,  Matrix{ComplexF64}}</code></pre><p>This function solves the SDP</p><p class="math-container">\[\max \{ \langle \rho, X \rangle :  \text{Tr}_{A}(X) = I_{B} , \Gamma(X) \succeq 0, X \succeq 0 \}\]</p><p>where <span>$\Gamma( \cdot)$</span> is the partial transpose with respect to the second system, and returns the optimal value and the optimizer, X. This is the primal problem for the SDP relaxation of the channel value. The relaxation is to the PPT cone. This has various interpretations. Note: we label the primal as the maximization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/CVChannel.jl/blob/479fa1e70d19b5434137f9017d99830796802d87/src/optimizations.jl#LL138-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.pptCVDual" href="#CVChannel.pptCVDual"><code>CVChannel.pptCVDual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pptCVDual(
    ρ :: Matrix{&lt;:Number},
    dimA :: Int,
    dimB :: Int
) :: Tuple{Float64,  Matrix{ComplexF64}, Matrix{ComplexF64}}</code></pre><p>This function solves the SDP</p><p class="math-container">\[\min \{ \text{Tr}(Y_{1}) : I_{A} \otimes Y_{1} - \Gamma(Y_{2}) \succeq \rho, Y_{2} \succeq 0, Y_{1} \in \text{Herm}(B) \}\]</p><p>where <span>$\Gamma( \cdot)$</span> is the partial transpose with respect to the second system, and returns the optimal value and optimizer, <span>$(Y_1 , Y_2 )$</span>. This is the dual problem for the SDP relaxation of the channel value. The relaxation is to the PPT cone. This has various interpretations. Note: we label the primal as the maximization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/CVChannel.jl/blob/479fa1e70d19b5434137f9017d99830796802d87/src/optimizations.jl#LL164-L179">source</a></section></article><h2 id="See-Saw-Optimization-of-the-CV"><a class="docs-heading-anchor" href="#See-Saw-Optimization-of-the-CV">See-Saw Optimization of the CV</a><a id="See-Saw-Optimization-of-the-CV-1"></a><a class="docs-heading-anchor-permalink" href="#See-Saw-Optimization-of-the-CV" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CVChannel.seesawCV" href="#CVChannel.seesawCV"><code>CVChannel.seesawCV</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seesawCV(
    init_states :: Vector{&lt;:AbstractMatrix},
    kraus_ops :: Vector{&lt;:AbstractMatrix},
    num_steps :: Int64;
    verbose :: Bool = false
)</code></pre><p>Performs the see-saw optimization technique to maximize the communication value (CV) of the channel described by <code>kraus_ops</code> over all states and measurements. This iterative and biconvex optimization technique combines coordinate ascent maximization with semidefinite programming. The number of iterations is determined by <code>num_steps</code> where each iteration consists of a two-step procedure:</p><ol><li>The POVM measurement is optimized with respect to a fixed state ensemble using the <a href="#CVChannel.fixedStateCV"><code>fixedStateCV</code></a> function.</li><li>The state ensemble is optimized with respect to a fixed povm state using the <a href="#CVChannel.fixedMeasurementCV"><code>fixedMeasurementCV</code></a> function.</li></ol><p>This procedure is initialized with <code>init_states</code> and after many iterations, a local maximum of the CV is found. The <code>verbose</code> keyword argument can be used to print out the CV evaluated in each step.</p><p>The see-saw method has shown success in similar encoding/decoding optimization problems in quantum information, <em>e.g.</em>, <a href="https://arxiv.org/abs/quant-ph/0307138v2">https://arxiv.org/abs/quant-ph/0307138v2</a> and <a href="https://arxiv.org/abs/quant-ph/0606078v1">https://arxiv.org/abs/quant-ph/0606078v1</a>. We note that our implementation is quite distinct from previous works, however, the core iterative approach remains the same.</p><p><strong>Returns</strong></p><p>A <code>Tuple</code> containing the following data in order:</p><ol><li><code>max_cv_tuple :: Tuple</code>, <code>(max_cv, opt_states, opt_povm)</code> A 3-tuple containing the maximal communication value and the optimal states/POVM that achieve this value.</li><li><code>cvs :: Vector{Float64}</code>, A list of each evaluated CV. Since states and measurements are optimized in each iteration, we have <code>length(cvs) == 2 * num_steps</code>.</li><li><code>opt_ensembles :: Vector{Vector{Matrix{ComplexF64}}}</code>, A list of state ensembles optimized in each step, where <code>length(opt_ensembles) == num_steps</code>.</li><li><code>opt_povms :: Vector{Vector{Matrix{ComplexF64}}}</code>, A list of POVM measurements optimized in each step, where <code>length(opt_povms) == num_steps</code>.</li></ol><div class="admonition is-warning"><header class="admonition-header">Optimum Not Guaranteed</header><div class="admonition-body"><p>This function is not guaranteed to find a global or local optima. However, <code>seesawCV</code> will always provide a lower bound on the communication value.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/CVChannel.jl/blob/479fa1e70d19b5434137f9017d99830796802d87/src/see-saw_optimization.jl#LL102-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.fixedStateCV" href="#CVChannel.fixedStateCV"><code>CVChannel.fixedStateCV</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fixedStateCV(
    states :: Vector{&lt;:AbstractMatrix},
    kraus_ops :: Vector{&lt;:AbstractMatrix}
) :: Tuple{Float64, Vector{Matrix{ComplexF64}}}</code></pre><p>For a fixed ensemble of <code>states</code> and quantum channel described by <code>kraus_ops</code>, the communication value (CV) is evaluated by maximizing over all POVM measurements. This optimization is expressed in primal form as the semidefinite program:</p><p class="math-container">\[\begin{matrix}
    \text{fixedStateCV}(\mathcal{N})&amp;= \max_{\{\Pi_x\}_{x}} \sum_x \text{Tr}\left[\Pi_x\mathcal{N}(\rho_x)\right] \\
    &amp; \\
    &amp; \text{s.t.} \quad \sum_x\Pi_x = \mathbb{I} \;\; \text{and} \;\; \Pi_x \geq 0
\end{matrix}\]</p><p>where each state <span>$\rho_x$</span> satisfies <span>$\text{Tr}[\rho_x] = 1$</span> and <span>$\rho_x \geq 0$</span>. The channel <span>$\mathcal{N}$</span> is applied to each state as <span>$\mathcal{N}(\rho_x) = \sum_j k \rho_x k^\dagger$</span>.</p><p><strong>Returns</strong></p><p>A <code>Tuple</code>, <code>(cv, opt_povm)</code> where <code>cv</code> is the evaluated communication value and <code>opt_povm</code> is the optimal POVM measurement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/CVChannel.jl/blob/479fa1e70d19b5434137f9017d99830796802d87/src/see-saw_optimization.jl#LL1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.fixedMeasurementCV" href="#CVChannel.fixedMeasurementCV"><code>CVChannel.fixedMeasurementCV</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fixedMeasurementCV(
    povm :: Vector{&lt;:AbstractMatrix},
    kraus_ops :: Vector{&lt;:AbstractMatrix}
) :: Tuple{Float64, Vector{Matrix{ComplexF64}}}</code></pre><p>For a fixed <code>povm</code> measurement and quantum channel described by <code>kraus_ops</code>, the communication value (CV) and optimal state encodings are computed. The fixed measurement CV is evaluated as</p><p class="math-container">\[\text{fixedMeasurementCV}(\mathcal{N}) = \sum_y ||\mathcal{N}^{\dagger}(\Pi_y)||_{\infty}\]</p><p>where <span>$||\mathcal{N}^{\dagger}(\Pi_y)||_{\infty}$</span> is the largest eigenvalue of the POVM element <span>$\Pi_y$</span> evolved by the adjoint channel, <span>$\mathcal{N}^{\dagger}(\Pi_y) = \sum_j k^{\dagger}_j \Pi_y k_j$</span>. The states which maximize the CV are simply the eigenvectors corresponding to the largest eigenvalue of each respective POVM element.</p><p><strong>Returns</strong></p><p>A <code>Tuple</code>, <code>(cv, opt_states)</code> where <code>cv</code> is the communication value and <code>opt_states</code> is the set of optimal states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/CVChannel.jl/blob/479fa1e70d19b5434137f9017d99830796802d87/src/see-saw_optimization.jl#LL53-L77">source</a></section></article><h2 id="Entanglement-Assisted-CV"><a class="docs-heading-anchor" href="#Entanglement-Assisted-CV">Entanglement Assisted CV</a><a id="Entanglement-Assisted-CV-1"></a><a class="docs-heading-anchor-permalink" href="#Entanglement-Assisted-CV" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CVChannel.eaCV" href="#CVChannel.eaCV"><code>CVChannel.eaCV</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eaCV( channel :: Choi, method :: Symbol = :primal )</code></pre><p>Numerically evaluates the entanglement-assisted communication value for the quantum channel <span>$\mathcal{N}$</span> given in the <a href="../channel_states/#CVChannel.Choi"><code>Choi</code></a> operator representation. This quantity is defined as:</p><p class="math-container">\[\begin{aligned}
    \text{eaCV}(\mathcal{N}) &amp; = \max_{\Omega^{AB}} \text{Tr}[\Omega^{AB}J_{\mathcal{N}}] \\
    \hspace{1cm}
    &amp; \text{s.t.} \quad  \text{Tr}_A[\Omega^{AB}] = \mathbb{I}^B; \\
    \hspace{1cm}
    &amp; \qquad \Omega^{AB} \in \text{POS}(A\;:\;B).
\end{aligned}\]</p><p>Note that for a channel <span>$\mathcal{N}$</span> with output Hilbert space dimension <span>$d_B$</span>, the entanglement-assisted CV is bound as</p><p class="math-container">\[\text{eaCV}(\mathcal{N}) \leq d_B \cdot \text{cv}(\mathcal{N}).\]</p><p>The <code>method</code> parameter accepts the values:</p><ul><li><code>:primal</code> - Solves the primal problem (see <a href="#CVChannel.eaCVPrimal"><code>eaCVPrimal</code></a>).</li><li><code>:dual</code> - Solves the dual problem (see <a href="#CVChannel.eaCVDual"><code>eaCVDual</code></a>).</li></ul><p><strong>Returns</strong></p><p>A Tuple containing <code>(max_cv, optimizer)</code> where <code>max_cv</code> is the communication value and <code>optimizer</code> is the matrix which achieves the optimum for the particular problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/CVChannel.jl/blob/479fa1e70d19b5434137f9017d99830796802d87/src/optimizations.jl#LL1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.eaCVPrimal" href="#CVChannel.eaCVPrimal"><code>CVChannel.eaCVPrimal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eaCVPrimal(
    ρ :: Matrix{&lt;:Number},
    dimA :: Int,
    dimB :: Int
) :: Tuple{Float64, Matrix{ComplexF64}}</code></pre><p>This function solves the SDP</p><p class="math-container">\[\max \{ \langle \rho, X \rangle :  \text{Tr}_{A}(X) = I_{B} , X \succeq 0 \}\]</p><p>and returns the optimal value and the optimizer, X. This is the primal problem of the SDP corresponding to the entanglement-assisted commmunication value. It is related to the channel min-entropy <span>$H_{\min}(A|B)_{\mathcal{J}(\mathcal{N})}$</span> by <span>$\text{eaCV}(\mathcal{N}) = 2^{-H_{\min}(A|B)_{\mathcal{J}(\mathcal{N})}}$</span>. (See <a href="https://arxiv.org/abs/1504.00233">Section 6.1 of this reference</a> for further details about the min-entropy.) Note: we label the primal as the maximization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/CVChannel.jl/blob/479fa1e70d19b5434137f9017d99830796802d87/src/optimizations.jl#LL38-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.eaCVDual" href="#CVChannel.eaCVDual"><code>CVChannel.eaCVDual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eaCVDual(
    ρ :: Matrix{&lt;:Number},
    dimA :: Int,
    dimB :: Int
) :: Tuple{Float64, Matrix{ComplexF64}}</code></pre><p>This function solves the SDP</p><p class="math-container">\[\min \{ \text{Tr}(Y) :  I_{A} \otimes Y \succeq \rho, Y \in \text{Herm}(B) \}\]</p><p>and returns the optimal value and the optimizer, Y. This is the dual problem for the SDP corresponding to the entanglement-assisted commmunication value. It is related to the channel min-entropy <span>$H_{\min}(A|B)_{\mathcal{J}(\mathcal{N})}$</span> by <span>$\text{eaCV}(\mathcal{N}) = 2^{-H_{\min}(A|B)_{\mathcal{J}(\mathcal{N})}}$</span>. (See <a href="https://arxiv.org/abs/1504.00233">Section 6.1 of this reference</a> for further details about the min-entropy.) Note: we label the primal as the maximization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/CVChannel.jl/blob/479fa1e70d19b5434137f9017d99830796802d87/src/optimizations.jl#LL66-L84">source</a></section></article><h2 id="CV-through-DPS-Hierarchy"><a class="docs-heading-anchor" href="#CV-through-DPS-Hierarchy">CV through DPS Hierarchy</a><a id="CV-through-DPS-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#CV-through-DPS-Hierarchy" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CVChannel.twoSymCVPrimal" href="#CVChannel.twoSymCVPrimal"><code>CVChannel.twoSymCVPrimal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">twoSymCVPrimal(channel :: Choi) :: Tuple{Float64,  Matrix{ComplexF64}}
twoSymCVPrimal(
    ρ :: Matrix{&lt;:Number},
    dimA :: Int,
    dimB :: Int
) :: Tuple{Float64,  Matrix{ComplexF64}}</code></pre><p>Given the <a href="../channel_states/#CVChannel.Choi"><code>Choi</code></a> operator representation of a channel, or alternatively, the Choi matrix <code>ρ</code> and its input output dimensions, this function solves the SDP</p><p class="math-container">\[\max \{ \langle \rho, X \rangle :  \text{Tr}_{A}(X) = I_{B} ,
                                        \Gamma^{B_{1}}(X) \succeq 0,
                                        X = (I_{A} \otimes \mathbb{F}_{B})X(I_{A} \otimes \mathbb{F}_{B}),
                                        X \succeq 0 \}\]</p><p>where <span>$\Gamma^{B_{1}}( \cdot)$</span> is the partial transpose with respect to the second system, and returns the optimal value and the optimizer, X. The conditions on X demand it is two-symmetric, i.e. an element of the lowest level of the <a href="https://arxiv.org/abs/quant-ph/0308032">DPS hierarchy.</a> Note: we label the primal as the maximization problem.</p><div class="admonition is-warning"><header class="admonition-header">Runs Out of Memory Easily</header><div class="admonition-body"><p>This function  will run out of memory for the tensor product of even qutrit to qutrit channels.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/CVChannel.jl/blob/479fa1e70d19b5434137f9017d99830796802d87/src/optimizations.jl#LL445-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.threeSymCVPrimal" href="#CVChannel.threeSymCVPrimal"><code>CVChannel.threeSymCVPrimal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">threeSymCVPrimal(channel :: Choi) :: Tuple{Float64,  Matrix{ComplexF64}}
threeSymCVPrimal(
    ρ :: Matrix{&lt;:Number},
    dimA :: Int,
    dimB :: Int
) :: Tuple{Float64,  Matrix{ComplexF64}}</code></pre><p>Given the <a href="../channel_states/#CVChannel.Choi"><code>Choi</code></a> operator representation of a channel, or alternatively, the Choi matrix <code>ρ</code> and its input output dimensions, this function solves the SDP</p><p class="math-container">\[\max \{ \langle \rho, X \rangle :  \text{Tr}_{A}(X) = I_{B} ,
                                        \Gamma^{B_{1}}(X) \succeq 0,
                                        X = (I_{A} \otimes W_{\pi})X(I_{A} \otimes W_{\pi}^{*}) \quad \forall \pi \in \mathcal{S_{3}},
                                        X \succeq 0 \}\]</p><p>where <span>$\Gamma^{B_{1}}( \cdot)$</span> is the partial transpose with respect to the second system, <span>$W_{\pi}$</span> is the unitary that permutes the subspaces according to permutation <span>$\pi$</span>. The function returns the optimal value and the optimizer, X. The conditions on X demand it is two-symmetric, i.e. an element of the lowest level of the <a href="https://arxiv.org/abs/quant-ph/0308032">DPS hierarchy.</a> Note: we label the primal as the maximization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/CVChannel.jl/blob/479fa1e70d19b5434137f9017d99830796802d87/src/optimizations.jl#LL484-L505">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../background/">« CV Background</a><a class="docs-footer-nextpage" href="../cv_multiplicativity/">CV Multiplicativity »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 21 October 2021 22:59">Thursday 21 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
