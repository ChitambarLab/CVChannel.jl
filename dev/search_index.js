var documenterSearchIndex = {"docs":
[{"location":"optimizer_interface/","page":"Optimization Backends","title":"Optimization Backends","text":"CurrentModule = CVChannel","category":"page"},{"location":"optimizer_interface/#Optimizer-Interface","page":"Optimization Backends","title":"Optimizer Interface","text":"","category":"section"},{"location":"optimizer_interface/","page":"Optimization Backends","title":"Optimization Backends","text":"The CVChannel package supports SCS (default) and MOSEK backends for optimizations. SCS is open-source whereas MOSEK requires a license (free for academic institutions). To obtain a MOSEK license, please visit https://www.mosek.com/license/request/?i=acp. For convenience, all optimization problems can be run through the qsolve! method which abstracts the backend from the optimization.","category":"page"},{"location":"optimizer_interface/","page":"Optimization Backends","title":"Optimization Backends","text":"qsolve!\nhasMOSEKLicense","category":"page"},{"location":"optimizer_interface/#CVChannel.qsolve!","page":"Optimization Backends","title":"CVChannel.qsolve!","text":"qsolve!( problem :: Problem; qsolve_kwargs..., cvx_kwargs... )\n\nA wrapper for Convex.solve!(...) that selects and configures the backend. The supported backends are SCS (default) and MOSEK (license required). The name qsolve! is chosen to avoid a namespace conflict with the Convex.solve!. This method is a featured utility for simplifying the interface with optimization software.\n\nqsolve_kargs:\n\nquiet :: Bool = true - If true, solve messages are suppressed.\nuse_mosek :: Bool = false - If true, MOSEK is used instead of SCS (default).\n\nThe cvx_kwargs... are keyword arguments passed to Convex.solve!:\n\ncheck_vexity :: Bool = true\nverbose :: Bool = true\nwarmstart :: Bool = false\nsilent_solver :: Bool = true\n\nFor details, see Convex.jl docs.\n\n\n\n\n\n","category":"function"},{"location":"optimizer_interface/#CVChannel.hasMOSEKLicense","page":"Optimization Backends","title":"CVChannel.hasMOSEKLicense","text":"hasMOSEKLicense() :: Bool\n\nReturns true if a MOSEK license is found locally. The ENV configuration is used to search for  a MOSEK license in the following order:\n\nENV[MOSEKLMM_LICENSE_FILE] a direct filepath to the MOSEK license.\nFilepath ENV[\"HOME\"]/mosek/mosek.lic\nFilepath ENV[\"PROFILE\"]/mosek/mosek.lic\n\nwarning: Expired MOSEK License\nThe method hasMOSEKLicense will return true if an expired MOSEK license is found. An error will be thrown if MOSEK is used with an expired license. To obtain a MOSEK license please visit https://www.mosek.com/license/request/?i=acp.\n\n\n\n\n\n","category":"function"},{"location":"communication_value/","page":"CV Optimizations","title":"CV Optimizations","text":"CurrentModule = CVChannel","category":"page"},{"location":"communication_value/#CV-Optimizations","page":"CV Optimizations","title":"CV Optimizations","text":"","category":"section"},{"location":"communication_value/#PPT-Relaxation-of-the-CV","page":"CV Optimizations","title":"PPT Relaxation of the CV","text":"","category":"section"},{"location":"communication_value/","page":"CV Optimizations","title":"CV Optimizations","text":"pptCV\npptCVPrimal\npptCVDual","category":"page"},{"location":"communication_value/#CVChannel.pptCV","page":"CV Optimizations","title":"CVChannel.pptCV","text":"pptCV( channel :: Choi, method :: Symbol = :primal )\n\nNumerically evaluates the positive partial transpose (PPT) relaxation of the communication value for the given Choi operator representation of a quantum channel. This optimization problem is expressed as,\n\nbeginaligned\n    textpptCV(mathcalN) =  max_Omega^AB textTrOmega^ABJ_mathcalN \n    hspace1cm\n     textst quad textTr_AOmega^AB = mathbbI^B \n    hspace1cm\n     qquad Omega^AB in textPPT(AB)\nendaligned\n\nwhere textPPT(A  B) indicates the cone of matrices with a positve partial transpose. The textPPT(AB) cone contains the textSEP(AB) cone therfore, the textpptCV is an upper bound for the textcv\n\ntextcv(mathcalN) leq textpptCV(mathcalN)\n\nwhere equality is found for the channels whose separable cone is the same as their PPT cone.\n\nThe method parameter accepts the values:\n\n:primal - Solves the primal problem (see pptCVPrimal).\n:dual - Solves the dual problem (see pptCVDual).\n\nReturns\n\nA Tuple containing (max_cv, optimizers...) where max_cv is the communication value and optimizers is the optimal value for each of the optimization paraameters.\n\n\n\n\n\n","category":"function"},{"location":"communication_value/#CVChannel.pptCVPrimal","page":"CV Optimizations","title":"CVChannel.pptCVPrimal","text":"pptCVPrimal(\n    ρ :: Matrix{<:Number},\n    dimA :: Int,\n    dimB :: Int\n) :: Tuple{Float64,  Matrix{ComplexF64}}\n\nThis function solves the SDP\n\nmax  langle rho X rangle   textTr_A(X) = I_B  Gamma(X) succeq 0 X succeq 0 \n\nwhere Gamma( cdot) is the partial transpose with respect to the second system, and returns the optimal value and the optimizer, X. This is the primal problem for the SDP relaxation of the channel value. The relaxation is to the PPT cone. This has various interpretations. Note: we label the primal as the maximization problem.\n\n\n\n\n\n","category":"function"},{"location":"communication_value/#CVChannel.pptCVDual","page":"CV Optimizations","title":"CVChannel.pptCVDual","text":"pptCVDual(\n    ρ :: Matrix{<:Number},\n    dimA :: Int,\n    dimB :: Int\n) :: Tuple{Float64,  Matrix{ComplexF64}, Matrix{ComplexF64}}\n\nThis function solves the SDP\n\nmin  textTr(Y_1)  I_A otimes Y_1 - Gamma(Y_2) succeq rho Y_2 succeq 0 Y_1 in textHerm(B) \n\nwhere Gamma( cdot) is the partial transpose with respect to the second system, and returns the optimal value and optimizer, (Y_1  Y_2 ). This is the dual problem for the SDP relaxation of the channel value. The relaxation is to the PPT cone. This has various interpretations. Note: we label the primal as the maximization problem.\n\n\n\n\n\n","category":"function"},{"location":"communication_value/#See-Saw-Optimization-of-the-CV","page":"CV Optimizations","title":"See-Saw Optimization of the CV","text":"","category":"section"},{"location":"communication_value/","page":"CV Optimizations","title":"CV Optimizations","text":"seesawCV\nfixedStateCV\nfixedMeasurementCV","category":"page"},{"location":"communication_value/#CVChannel.seesawCV","page":"CV Optimizations","title":"CVChannel.seesawCV","text":"seesawCV(\n    init_states :: Vector{<:AbstractMatrix},\n    kraus_ops :: Vector{<:AbstractMatrix},\n    num_steps :: Int64;\n    verbose :: Bool = false\n)\n\nPerforms the see-saw optimization technique to maximize the communication value (CV) of the channel described by kraus_ops over all states and measurements. This iterative and biconvex optimization technique combines coordinate ascent maximization with semidefinite programming. The number of iterations is determined by num_steps where each iteration consists of a two-step procedure:\n\nThe POVM measurement is optimized with respect to a fixed state ensemble using the fixedStateCV function.\nThe state ensemble is optimized with respect to a fixed povm state using the fixedMeasurementCV function.\n\nThis procedure is initialized with init_states and after many iterations, a local maximum of the CV is found. The verbose keyword argument can be used to print out the CV evaluated in each step.\n\nThe see-saw method has shown success in similar encoding/decoding optimization problems in quantum information, e.g., https://arxiv.org/abs/quant-ph/0307138v2 and https://arxiv.org/abs/quant-ph/0606078v1. We note that our implementation is quite distinct from previous works, however, the core iterative approach remains the same.\n\nReturns\n\nA Tuple containing the following data in order:\n\nmax_cv_tuple :: Tuple, (max_cv, opt_states, opt_povm) A 3-tuple containing the maximal communication value and the optimal states/POVM that achieve this value.\ncvs :: Vector{Float64}, A list of each evaluated CV. Since states and measurements are optimized in each iteration, we have length(cvs) == 2 * num_steps.\nopt_ensembles :: Vector{Vector{Matrix{ComplexF64}}}, A list of state ensembles optimized in each step, where length(opt_ensembles) == num_steps.\nopt_povms :: Vector{Vector{Matrix{ComplexF64}}}, A list of POVM measurements optimized in each step, where length(opt_povms) == num_steps.\n\nwarning: Optimum Not Guaranteed\nThis function is not guaranteed to find a global or local optima. However, seesawCV will always provide a lower bound on the communication value.\n\n\n\n\n\n","category":"function"},{"location":"communication_value/#CVChannel.fixedStateCV","page":"CV Optimizations","title":"CVChannel.fixedStateCV","text":"fixedStateCV(\n    states :: Vector{<:AbstractMatrix},\n    kraus_ops :: Vector{<:AbstractMatrix}\n) :: Tuple{Float64, Vector{Matrix{ComplexF64}}}\n\nFor a fixed ensemble of states and quantum channel described by kraus_ops, the communication value (CV) is evaluated by maximizing over all POVM measurements. This optimization is expressed in primal form as the semidefinite program:\n\nbeginmatrix\n    textfixedStateCV(mathcalN)= max_Pi_x_x sum_x textTrleftPi_xmathcalN(rho_x)right \n     \n     textst quad sum_xPi_x = mathbbI  textand  Pi_x geq 0\nendmatrix\n\nwhere each state rho_x satisfies textTrrho_x = 1 and rho_x geq 0. The channel mathcalN is applied to each state as mathcalN(rho_x) = sum_j k rho_x k^dagger.\n\nReturns\n\nA Tuple, (cv, opt_povm) where cv is the evaluated communication value and opt_povm is the optimal POVM measurement.\n\n\n\n\n\n","category":"function"},{"location":"communication_value/#CVChannel.fixedMeasurementCV","page":"CV Optimizations","title":"CVChannel.fixedMeasurementCV","text":"fixedMeasurementCV(\n    povm :: Vector{<:AbstractMatrix},\n    kraus_ops :: Vector{<:AbstractMatrix}\n) :: Tuple{Float64, Vector{Matrix{ComplexF64}}}\n\nFor a fixed povm measurement and quantum channel described by kraus_ops, the communication value (CV) and optimal state encodings are computed. The fixed measurement CV is evaluated as\n\ntextfixedMeasurementCV(mathcalN) = sum_y mathcalN^dagger(Pi_y)_infty\n\nwhere mathcalN^dagger(Pi_y)_infty is the largest eigenvalue of the POVM element Pi_y evolved by the adjoint channel, mathcalN^dagger(Pi_y) = sum_j k^dagger_j Pi_y k_j. The states which maximize the CV are simply the eigenvectors corresponding to the largest eigenvalue of each respective POVM element.\n\nReturns\n\nA Tuple, (cv, opt_states) where cv is the communication value and opt_states is the set of optimal states.\n\n\n\n\n\n","category":"function"},{"location":"communication_value/#Entanglement-Assisted-CV","page":"CV Optimizations","title":"Entanglement Assisted CV","text":"","category":"section"},{"location":"communication_value/","page":"CV Optimizations","title":"CV Optimizations","text":"eaCV\neaCVPrimal\neaCVDual","category":"page"},{"location":"communication_value/#CVChannel.eaCV","page":"CV Optimizations","title":"CVChannel.eaCV","text":"eaCV( channel :: Choi, method :: Symbol = :primal )\n\nNumerically evaluates the entanglement-assisted communication value for the quantum channel mathcalN given in the Choi operator representation. This quantity is defined as:\n\nbeginaligned\n    texteaCV(mathcalN)  = max_Omega^AB textTrOmega^ABJ_mathcalN \n    hspace1cm\n     textst quad  textTr_AOmega^AB = mathbbI^B \n    hspace1cm\n     qquad Omega^AB in textPOS(AB)\nendaligned\n\nNote that for a channel mathcalN with output Hilbert space dimension d_B, the entanglement-assisted CV is bound as\n\ntexteaCV(mathcalN) leq d_B cdot textcv(mathcalN)\n\nThe method parameter accepts the values:\n\n:primal - Solves the primal problem (see eaCVPrimal).\n:dual - Solves the dual problem (see eaCVDual).\n\nReturns\n\nA Tuple containing (max_cv, optimizer) where max_cv is the communication value and optimizer is the matrix which achieves the optimum for the particular problem.\n\n\n\n\n\n","category":"function"},{"location":"communication_value/#CVChannel.eaCVPrimal","page":"CV Optimizations","title":"CVChannel.eaCVPrimal","text":"eaCVPrimal(\n    ρ :: Matrix{<:Number},\n    dimA :: Int,\n    dimB :: Int\n) :: Tuple{Float64, Matrix{ComplexF64}}\n\nThis function solves the SDP\n\nmax  langle rho X rangle   textTr_A(X) = I_B  X succeq 0 \n\nand returns the optimal value and the optimizer, X. This is the primal problem of the SDP corresponding to the entanglement-assisted commmunication value. It is related to the channel min-entropy H_min(AB)_mathcalJ(mathcalN) by texteaCV(mathcalN) = 2^-H_min(AB)_mathcalJ(mathcalN). (See Section 6.1 of this reference for further details about the min-entropy.) Note: we label the primal as the maximization problem.\n\n\n\n\n\n","category":"function"},{"location":"communication_value/#CVChannel.eaCVDual","page":"CV Optimizations","title":"CVChannel.eaCVDual","text":"eaCVDual(\n    ρ :: Matrix{<:Number},\n    dimA :: Int,\n    dimB :: Int\n) :: Tuple{Float64, Matrix{ComplexF64}}\n\nThis function solves the SDP\n\nmin  textTr(Y)   I_A otimes Y succeq rho Y in textHerm(B) \n\nand returns the optimal value and the optimizer, Y. This is the dual problem for the SDP corresponding to the entanglement-assisted commmunication value. It is related to the channel min-entropy H_min(AB)_mathcalJ(mathcalN) by texteaCV(mathcalN) = 2^-H_min(AB)_mathcalJ(mathcalN). (See Section 6.1 of this reference for further details about the min-entropy.) Note: we label the primal as the maximization problem.\n\n\n\n\n\n","category":"function"},{"location":"communication_value/#CV-through-DPS-Hierarchy","page":"CV Optimizations","title":"CV through DPS Hierarchy","text":"","category":"section"},{"location":"communication_value/","page":"CV Optimizations","title":"CV Optimizations","text":"twoSymCVPrimal\nthreeSymCVPrimal","category":"page"},{"location":"communication_value/#CVChannel.twoSymCVPrimal","page":"CV Optimizations","title":"CVChannel.twoSymCVPrimal","text":"twoSymCVPrimal(channel :: Choi) :: Tuple{Float64,  Matrix{ComplexF64}}\ntwoSymCVPrimal(\n    ρ :: Matrix{<:Number},\n    dimA :: Int,\n    dimB :: Int\n) :: Tuple{Float64,  Matrix{ComplexF64}}\n\nGiven the Choi operator representation of a channel, or alternatively, the Choi matrix ρ and its input output dimensions, this function solves the SDP\n\nmax  langle rho X rangle   textTr_A(X) = I_B \n                                        Gamma^B_1(X) succeq 0\n                                        X = (I_A otimes mathbbF_B)X(I_A otimes mathbbF_B)\n                                        X succeq 0 \n\nwhere Gamma^B_1( cdot) is the partial transpose with respect to the second system, and returns the optimal value and the optimizer, X. The conditions on X demand it is two-symmetric, i.e. an element of the lowest level of the DPS hierarchy. Note: we label the primal as the maximization problem.\n\nwarning: Runs Out of Memory Easily\nThis function  will run out of memory for the tensor product of even qutrit to qutrit channels.\n\n\n\n\n\n","category":"function"},{"location":"communication_value/#CVChannel.threeSymCVPrimal","page":"CV Optimizations","title":"CVChannel.threeSymCVPrimal","text":"threeSymCVPrimal(channel :: Choi) :: Tuple{Float64,  Matrix{ComplexF64}}\nthreeSymCVPrimal(\n    ρ :: Matrix{<:Number},\n    dimA :: Int,\n    dimB :: Int\n) :: Tuple{Float64,  Matrix{ComplexF64}}\n\nGiven the Choi operator representation of a channel, or alternatively, the Choi matrix ρ and its input output dimensions, this function solves the SDP\n\nmax  langle rho X rangle   textTr_A(X) = I_B \n                                        Gamma^B_1(X) succeq 0\n                                        X = (I_A otimes W_pi)X(I_A otimes W_pi^*) quad forall pi in mathcalS_3\n                                        X succeq 0 \n\nwhere Gamma^B_1( cdot) is the partial transpose with respect to the second system, W_pi is the unitary that permutes the subspaces according to permutation pi. The function returns the optimal value and the optimizer, X. The conditions on X demand it is two-symmetric, i.e. an element of the lowest level of the DPS hierarchy. Note: we label the primal as the maximization problem.\n\n\n\n\n\n","category":"function"},{"location":"channel_states/","page":"Channels, States, and Operations","title":"Channels, States, and Operations","text":"CurrentModule = CVChannel","category":"page"},{"location":"channel_states/#Channels,-States,-and-Operations","page":"Channels, States, and Operations","title":"Channels, States, and Operations","text":"","category":"section"},{"location":"channel_states/#Channels","page":"Channels, States, and Operations","title":"Channels","text":"","category":"section"},{"location":"channel_states/","page":"Channels, States, and Operations","title":"Channels, States, and Operations","text":"Choi\nis_choi_matrix\nparChoi\nchoi\nisometricChannel\ncomplementaryChannel\nkrausAction\ndepolarizingChannel\ndephrasureChannel\nwernerHolevoChannel\nsiddhuChannel\ngeneralizedSiddhu\nGADChannel","category":"page"},{"location":"channel_states/#CVChannel.Choi","page":"Channels, States, and Operations","title":"CVChannel.Choi","text":"Choi( JN :: AbstractMatrix, in_dim :: Int, out_dim :: Int ) :: Choi{<:Number}\n\nChoi( N :: Function, in_dim :: Int, out_dim :: Int ) :: Choi{ComplexF64}\n\nChoi( kraus_ops :: Vector{<:AbstractMatrix} ) :: Choi{ComplexF64}\n\nConstructs the Choi matrix representation of a quantum channel. If either a function N or set of kraus operators is provided as input, the Choi matrix is constructed with the choi method.\n\nThe Choi type contains the fields:\n\nJN :: Matrix{<:Number} - The choi matrix.\nin_dim :: Int - The channel's input dimension.\nout_dim :: Int - The Channel's output dimension.\n\nA DomainError is thrown if is_choi_matrix returns false.\n\n\n\n\n\n","category":"type"},{"location":"channel_states/#CVChannel.is_choi_matrix","page":"Channels, States, and Operations","title":"CVChannel.is_choi_matrix","text":"is_choi_matrix(JN :: AbstractMatrix, dimA :: Int, dimB :: Int) :: Bool\n\nReturns true if the supplied matrix JN is a Choi operator. This function returns false if\n\nsize(JN) != (dimA * dimB, dimA * dimB)\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.parChoi","page":"Channels, States, and Operations","title":"CVChannel.parChoi","text":"parChoi(chan1 :: Choi, chan2 :: Choi) :: Choi\n\nReturns the tensor product of two Choi matrices\n\n    J^AB_mathcalNotimes J^AB_mathcalM to\n    J^AABB_mathcalNotimesmathcalM\n\nwhere J^AB_mathcalN and J^AB_mathcalM are the Choi matrices for chan1 and chan2 respectively. Note the implicit swap between systems B leftrightarrow A.\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.choi","page":"Channels, States, and Operations","title":"CVChannel.choi","text":"choi(𝒩 :: Function, Σ :: Int, Λ :: Int) :: Matrix{ComplexF64}\nchoi(kraus_ops :: Vector{<:AbstractMatrix}) :: Matrix{ComplexF64}\n\nThis function returns the Choi state of a channel represented either as a generic function 𝒩 or a set of Kraus operators kraus_ops. It does this using that\n\n        J_mathcalN = sum_ab in Sigma E_ab otimes mathcalN(E_ab) \n\nwhere Sigma is the finite alphabet indexing the input space and E_ab is a square matrix of dimension Sigma with a 1 in the (ab) entry and a 0 everywhere else. The input Lambda is the output dimension. Note this assumes you have a function that calculates mathcalN(X) for arbitrary input X. As many of the functions for channels in this module have multiple parameters, please note that if you have a channel function 𝒩(ρ, p, q) that calculates mathcalN_pq(rho), you can declare a function 𝒩_xy(ρ) = 𝒩(ρ,x,y) for fixed (x,y) and then call, choi(𝒩_xy, Σ).\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.isometricChannel","page":"Channels, States, and Operations","title":"CVChannel.isometricChannel","text":"isometricChannel(kraus_ops :: Vector) :: Matrix\n\nThis function builds the isometric representation V of a channel mathcalN A to B from the Kraus operators K_i. It does this by calculating\n\n    V = sum_i K_i otimes irangle\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.complementaryChannel","page":"Channels, States, and Operations","title":"CVChannel.complementaryChannel","text":"complementaryChannel(kraus_ops :: Vector) :: Vector\n\nThis function takes a set of Kraus operators for a channel mathcalN_A to B and returns a set of Kraus operators for the complementary channel, mathcalN^c_A to E. It does this by generating the Kraus operators of the isometric representation of the channel followed by partial trace on the B space.\n\ninfo: Info\nIf mathcalN_A to B is already isometric, the code lets dimE=2 so that functions are well behaved.\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.krausAction","page":"Channels, States, and Operations","title":"CVChannel.krausAction","text":"krausAction(kraus_ops :: Vector, X)\n\nThis function takes a set of Kraus operators for a channel mathcalN_A to B and returns the output of the channel for input X. That is, given input X it returns\n\n    mathcalN_A to B(X) = sum_i K_i X K_i^ast\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.depolarizingChannel","page":"Channels, States, and Operations","title":"CVChannel.depolarizingChannel","text":"depolarizingChannel(ρ :: Matrix{Float64}, q :: Union{Int,Float64}) :: Matrix{ComplexF64}\n\nThis calculates the action of the depolarizing channel,\n\nDelta_q(rho) = (1-q)rho + q textTr(rho) frac1d I_AB \n\nwhere q in 01 Note these channels are the channels covariant with respect to the unitary group.\n\nA DomainError is thrown if:\n\nMatrix ρ is not square\nInput q does not satisfy 0 ≤ q ≤ 1\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.dephrasureChannel","page":"Channels, States, and Operations","title":"CVChannel.dephrasureChannel","text":"dephrasureChannel(\n    ρ :: Matrix{<:Number},\n    p :: Union{Int,Float64},\n    q :: Union{Int,Float64}\n) :: Matrix{ComplexF64}\n\nThis function calculates the action of the dephrasureChannel,\n\nmathcalN_pq( rho) = (1-q)((1-p) rho + pZ rho Z) + q textTr( rho) erangle langle e\n\nwhere pq in 01, Z is the Pauli-Z matrix, and eranglelangle e an  error  flag orthogonal to the  Hilbert space of input state rho.\n\nA DomainError is thrown if:\n\nMatrix ρ is not 2x2\nInputs p or q do not satisdy 0 ≤ p,q ≤ 1\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.wernerHolevoChannel","page":"Channels, States, and Operations","title":"CVChannel.wernerHolevoChannel","text":"wernerHolevoChannel(ρ :: Matrix{<:Number}, λ :: Union{Int,Float64}) :: Matrix{ComplexF64}\n\nThis function calculates the action of the generalized Werner-Holevo channels\n\n    mathcalW_dlambda(rho) = lambda Phi_0(ρ) + (1-lambda) Phi_1(ρ)\n\nwhere lambda in 01. This means these are convex combinations of the original Werner-Holevo channels which are defined as\n\n    Phi_0(ρ) = frac1d+1(textTrrhoI_d +ρ^T) hspace1cm\n    Phi_1(ρ) = frac1d-1(textTrrhoI_d -ρ^T) \n\nNote the Choi matrices of these generalized channels are the (unnormalized) Werner states.\n\nA DomainError is thrown if:\n\nMatrix ρ is not square\np is not in  range 0 ≤ p ≤ 1\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.siddhuChannel","page":"Channels, States, and Operations","title":"CVChannel.siddhuChannel","text":"siddhuChannel(ρ :: Matrix{<:Number}, s :: Union{Int,Float64}) :: Matrix{<:Number}\n\nThis function calculates the action of the Siddhu channel N_s which is defined by Kraus operators:\n\n    beginaligned\n    K_0 = beginbmatrix sqrts  0  0  0  0  0  0  1  0 endbmatrix\n    hspace5mm\n    K_1 = beginbmatrix 0  0  0  sqrt1-s  0  0  0  0  1 endbmatrix \n    endaligned\n\nwhere s in 012. This channel was introduced in Equation 9 of this paper.\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.generalizedSiddhu","page":"Channels, States, and Operations","title":"CVChannel.generalizedSiddhu","text":"generalizedSiddhu(\n      ρ :: Matrix{<:Number},\n      s :: Union{Int,Float64},\n      μ :: Union{Int,Float64}\n) :: Matrix{<:Number}\n\nThis function calculates the action of the generalized Siddhu channel mathcalN_smu on the qutrit state rho. The action of the channel is defined by Kraus operators:\n\n    beginaligned\n    K_0 = beginbmatrix\n                sqrts  0  0 \n                0  sqrt1-mu  0 \n                0  0  sqrtmu\n             endbmatrix\n    hspace5mm\n    K_1 = beginbmatrix\n                0  0  sqrt1-mu \n                sqrt1-s  0  0 \n                0  sqrtmu  0\n            endbmatrix \n    endaligned\n\nwhere s in 012, mu in 01. This channel was introduced by Leditzky et al. (cite when on arxiv).\n\nA DomainError is thrown if:\n\nMatrix ρ is not square\nρ is not a 3-dimensional matrix\ns is not in range 0 ≤ s ≤ 1/2\nμ is not in range 0 ≤ μ ≤ 1\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.GADChannel","page":"Channels, States, and Operations","title":"CVChannel.GADChannel","text":"GADChannel(\n    ρ :: Matrix{<:Number},\n    p :: Union{Int,Float64},\n    n :: Union{Int,Float64}\n) :: Matrix{<:Number}\n\nThis function calculates the action of the generalized (qubit) amplitude damping channel mathcalA_pn which is defined by Kraus operators:\n\n    beginaligned\n    K_0 = sqrt1-n beginbmatrix 1  0  0  sqrt1-p endbmatrix\n    hspace5mm\n    K_1 = sqrtp(1-n) beginbmatrix 0  1  0  0 endbmatrix  \n    K_2 = sqrtn beginbmatrix sqrt1-p  0  0  1 endbmatrix\n    hspace5mm\n    K_3 = sqrtpn beginbmatrix 0  0  1  0 endbmatrix\n    endaligned\n\nwhere pn in 01. This channel may be found in Section 3 of this paper.\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#States","page":"Channels, States, and Operations","title":"States","text":"","category":"section"},{"location":"channel_states/","page":"Channels, States, and Operations","title":"Channels, States, and Operations","text":"wernerState\naxisymmetricState\nhaarStates","category":"page"},{"location":"channel_states/#CVChannel.wernerState","page":"Channels, States, and Operations","title":"CVChannel.wernerState","text":"wernerState(dim :: Int, p ::Union{Int,Float64}) :: Matrix{Float64}\n\nThis function constructs the Werner states,\n\n    sigma_dp = p fracPi_0d+1 choose 2 + (1-p) fracPi_1d choose 2\n\nwhere p in 01 and Pi_0 Pi_1 are the projectors onto the symmetric and anti-symmetric subspaces respectively. They can be determined by\n\n    Pi_0 = frac12 (I_A otimes I_B + mathbbF) hspace1cm Pi_1 = frac12(I_A otimes I_B - mathbbF)\n\nwhere mathbbF is the swap operator.\n\nA DomainError is thrown if:\n\nd ≤ 1\np is not in range 0 ≤ p ≤ 1\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.axisymmetricState","page":"Channels, States, and Operations","title":"CVChannel.axisymmetricState","text":"axisymmetricState(\n    d :: Int64,\n    x :: Union{Int,Float64},\n    y :: Union{Int,Float64}\n) :: Matrix{Float64}\n\nConstruct the axisymmetric state rho^textaxi as described in section IV.C. of this paper. This state is a bipartite quantum state with each subspace having dimension d. The diagonal of rho^textaxi is parameterized as\n\n    rho^textaxi_jjjj = frac1d^2+a quad textandquad rho^textaxi_jkjk = frac1d^2- fracad-1  (jneq k)\n\nwhile the off-diagonals are expressed as\n\n    rho^textaxi_jjkk = b\n\nwhere a = yfracd-1d and b = fracxsqrtd(d-1). All remaining elements of rho^textaxi are zero. Inputs x and y of the axisymmetricState function parameterize rho^textaxi and are constrained as:\n\n-frac1dsqrtd-1 leq y leq fracsqrtd-1d\n-frac1sqrtd(d-1)leq x leq sqrtfracd-1d\n-frac1sqrtdleft( y + frac1dsqrtd-1right) leq x leq fracd-1sqrtdleft(y + frac1dsqrtd-1 right)\n\nIf any of the constraints above do not hold, a DomainError is thrown.\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.haarStates","page":"Channels, States, and Operations","title":"CVChannel.haarStates","text":"haarStates(n :: Int64, d :: Int64) :: Vector{Matrix{ComplexF64}}\n\nConstructs a list of n random states on a d-dimensional Hilbert space according to the Haar measure.\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#Operations","page":"Channels, States, and Operations","title":"Operations","text":"","category":"section"},{"location":"channel_states/","page":"Channels, States, and Operations","title":"Channels, States, and Operations","text":"isPPT\nswapOperator\npermuteSubsystems\nshiftOperator\ndiscreteWeylOperator","category":"page"},{"location":"channel_states/#CVChannel.isPPT","page":"Channels, States, and Operations","title":"CVChannel.isPPT","text":"isPPT(x, sys :: Int, dims :: Vector) :: Bool\n\nThis function returns true if the input state x is PPT with respect to the (sys)th system. False otherwise. dims is a vector of the sizes of the subsystems.\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.swapOperator","page":"Channels, States, and Operations","title":"CVChannel.swapOperator","text":"swapOperator(dim :: Int) :: Matrix{Float64}\n\nThis function is the swap operator mathbbF which is defined by the action\n\nmathbbF(u otimes v) = v otimes u hspace5mm uv in mathcalH_A \n\nThe function uses that mathbbF = sum_ab in Sigma E_ab otimes E_ba where E_ab is a square matrix of dimension Sigma with a one in the (ab) entry and a 0 everywhere else.\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.permuteSubsystems","page":"Channels, States, and Operations","title":"CVChannel.permuteSubsystems","text":"permuteSubsystems(\n    ρ:: Vector,\n    perm::Vector{Int64},\n    dims::Vector{Int64}\n) :: Vector\n\nThis function returns the vector with the subsystems permuted. For example, given three subspaces ABC, and the permutation pi defined by (ABC) xrightarrowpi (CAB) the function implements the process:\n\n    e_irangle_A e_j rangle_B e_k rangle_C xrightarrowpi\n    e_k rangle_C e_irangle_A  e_j rangle_B  \n\nby re-indexing the vector, permuting the indices appropriately, and converting it back into a vector.\n\n\n\n\n\npermuteSubsystems(\n    ρ:: Matrix,\n    perm::Vector{Int64},\n    dims::Vector{Int64}\n) :: Matrix\n\nThis function returns the matrix with the subsystems permuted. It is a generalization of the vector code. For example, given three subspaces ABC, and the permutation pi defined by (ABC) xrightarrowpi (CAB) the function implements the process:\n\ne_iranglelangle e_i_Aotimes e_j ranglelangle e_j_Botimes e_k ranglelangle e_k_C xrightarrowpi\ne_k ranglelangle e_k_Cotimes e_iranglelangle e_i_A otimes  e_j ranglelangle e_j_B \n\nby re-indexing the matrix, permuting the indices, and reconstructing the matrix. Both bra and ket indices receive the same permutation.\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.shiftOperator","page":"Channels, States, and Operations","title":"CVChannel.shiftOperator","text":"shiftOperator(d::Int64) :: Matrix\n\nThis function returns the operator that shifts the computational basis mod d for complex Euclidean space of dimension d. That is, it returns the operator S defined by the action\n\n    Skrangle = k+1 mod d rangle\n\n\n\n\n\n","category":"function"},{"location":"channel_states/#CVChannel.discreteWeylOperator","page":"Channels, States, and Operations","title":"CVChannel.discreteWeylOperator","text":"discreteWeylOperator(m :: Int64, n :: Int64, d :: Int64)\n\nThis function returns the (m,n)^th unitary for generating the generalized Bell basis. They are defined by their action on the computational basis:\n\n    U_mne_krangle = e^2 pi mk i  d e_k+nrangle\n\nThese are the discrete Weyl Operator basis. See Section 3 of this paper for further details.\n\nwarning: Warning\nDifferent works define the discrete Weyl operators differently such that the phase or ordering may differ. Please check your reference.\n\n\n\n\n\n","category":"function"},{"location":"background/#CV-Background","page":"CV Background","title":"CV Background","text":"","category":"section"},{"location":"background/","page":"CV Background","title":"CV Background","text":"The communication value (CV) measures the performance of classical communication over a channel.","category":"page"},{"location":"background/#Classical-Channels","page":"CV Background","title":"Classical Channels","text":"","category":"section"},{"location":"background/","page":"CV Background","title":"CV Background","text":"A classical channel mathbfP  n to n is treated as a black-box with transition probabilities P(yx) where xinn and yinn.","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"(Image: Classical Channel)","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"The communication value (textcv) of a classical channel is defined as:","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"textcv(mathbfP) = sum_yinn max_xinn P(yx)","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"The communication value is simply understood as being analogous to the maximal success probability of guessing the input x given the output y. Furthermore, this quantity can be applied to any communication channel that can be characterized by its transition probabilities P(yx) and is therefore a device-independent measure of communication performance.","category":"page"},{"location":"background/#Quantum-Channels","page":"CV Background","title":"Quantum Channels","text":"","category":"section"},{"location":"background/","page":"CV Background","title":"CV Background","text":"A quantum channel is defined as a completely-positive trace-preserving map mathcalN in textCPTP(A to B) where A and B denote the input and output Hilbert spaces respectively.","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"(Image: Quantum Channel)","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"Classical communication over a quantum channel is performed in three steps:","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"The input xinn is encoded into a quantum state rho_xinmathcalH^A on the input Hilbert space.\nState rho_x is sent through the quantum channel mathcalN evolving the state to mathcalN(rho_x)inmathcalH^B on the output Hilbert sapce.\nThe evolved state is measured with the positive operator-valued measure (POVM) Pi_y_y=1^n to decode the value yinn.","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"We note that the formal restrictions on quantum states are rho_xinmathcalH^A, rho_x = rho_x^dagger, textTrrho_x = 1, and rho_x geq 0. Likewise, the restrictions on POVMs are Pi_y in mathcalH^B, Pi_y geq 0, Pi_y = Pi_y^dagger, and sum_y=1^nPi_y = mathbbI_B.","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"The communication value of a quantum channel mathcalN is defined as:","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"textcv(mathcalN)=\n    max_Pi_y_y=1^n rho_x _x=1^n\n    textcv(mathbfP)    P(yx) = textTrPi_ymathcalN(rho_x)","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"where n nin mathbbN are selected as the smallest values that yield the maximal value for the communication value. In practice, n=n=d_B^2 where d_B is the Hilbert space dimension of the POVM measurement.","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"The communication value of a quantum channel can alternatively be cast as an optimization over the separable cone, textSEP(AB), where A and B are the input and output Hilbert spaces of channel mathcalN. The communication value of a quantum channel then takes the form:","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"beginaligned\n    textcv(mathcalN) = max_Omega^AB textTrOmega^ABJ_mathcalN \n    hspace1cm\n     textst quad textTr_AOmega^AB = mathbbI^B \n    hspace1cm\n     qquad Omega^AB in textSEP(AB)\nendaligned","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"where the quantum channel mathcalN is represented by its Choi operator J_mathcalN.","category":"page"},{"location":"background/#Certifying-Communication-Value","page":"CV Background","title":"Certifying Communication Value","text":"","category":"section"},{"location":"background/","page":"CV Background","title":"CV Background","text":"In general cases, the communication value of a quantum channel is challenging to compute. However, upper and lower bounds can be computed with relative efficiency:","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"The upper bound is computed using the pptCV method to evaluate the :dual of the PPT Relaxation of the CV.\nThe lower bound is computed using the seesawCV method to evaluate the See-Saw Optimization of the CV.","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"Using these bounds, we certify the communication value as:","category":"page"},{"location":"background/","page":"CV Background","title":"CV Background","text":"textseesawCV(mathcalN) leq textcv(mathcalN) leq textpptCV(mathcalN textdual)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CVChannel","category":"page"},{"location":"#CVChannel.jl","page":"Home","title":"CVChannel.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package and numerical analysis support the findings in The Communication Value of a Quantum Channel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CVChannel","category":"page"},{"location":"#CVChannel.CVChannel","page":"Home","title":"CVChannel.CVChannel","text":"A numerics library for evaluating the communication value of a quantum channel.\n\nThe communication value (CV) quantifies the performance of single-copy classical communication.\n\nFeatures:\n\nConvex optimization methods for certifying the communication value of a quantum channel.\nTools for certifying the non-multiplicativity of the communication value for quantum channels.\n\nContents:\n\nA formal introduction to the communication value is found in the CV Background section.\nDocumentation for our optimization methods is found in the CV Optimizations section.\nDocumentation for our multiplicativity analysis tools are found in the CV Multiplicativity section.\nSupporting methods are found in the Utilities section.\n\n\n\n\n\n","category":"module"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install Julia: https://julialang.org/downloads/\nAdd the CVChannel.jl package from the Julia command prompt:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"CVChannel\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To import the CVChannel.jl, run using CVChannel in the desired Julia file or workspace.","category":"page"},{"location":"#Numerical-Analysis","page":"Home","title":"Numerical Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The numerical analysis in this work investigates (non-)multiplicativity of the communication value over a wide range of quantum channels.","category":"page"},{"location":"#Scripts","page":"Home","title":"Scripts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project uses scripts to verify and investigate the (non-)multiplicativity of different quantum channels. Scripts are found in the ./script directory and are categorized into two directories as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"./script/verify - assert a numerical fact or result.\n./script/investigate - collects data for analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instructions for running scripts can be found in the README.md","category":"page"},{"location":"#Notebooks","page":"Home","title":"Notebooks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our analysis uses Jupyter notebooks for figures and demonstrations. Jupyter notebooks are found in the ./notebook directory. Notebooks are most conveniently viewed on github, however, instructions for running notebooks are found in README.md.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Add Citation Info\n","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are interested in contributing to this software, please reach out to the authors. Development instructions are found in the README.md.","category":"page"},{"location":"#Licensing","page":"Home","title":"Licensing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CVChannel.jl is released under the MIT License.","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Development of CVChannel.jl was made possible by the advisory of Eric Chitambar and support from the Electrical and Computer Engineering and Physics departments at the University of Illinois at Urbana-Champaign.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Add funding\n","category":"page"},{"location":"cv_multiplicativity/","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"CurrentModule = CVChannel","category":"page"},{"location":"cv_multiplicativity/#CV-Multiplicativity","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"","category":"section"},{"location":"cv_multiplicativity/","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"An objective of this software is identify when parallel quantum channels have a communication value greater than the product of its constituents.","category":"page"},{"location":"cv_multiplicativity/","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"(Image: Parallel Quantum Channels)","category":"page"},{"location":"cv_multiplicativity/","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"This super-multiplicativity, is a nonclassical feature of quantum communication systems that results from the entanglement across the input and output Hilbert spaces of the two parallel channels. Formally, we define the communication value of two quantum channels mathcalN and mathcalM to be super-multiplicative when","category":"page"},{"location":"cv_multiplicativity/","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"textcv(mathcalN)textcv(mathcalM)  textcv(mathcalNotimesmathcalM)","category":"page"},{"location":"cv_multiplicativity/","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"For classical channels, the input and output Hilbert spaces are separable, hence, the communication value is always found to be multiplicative (equality holds for the above expression).","category":"page"},{"location":"cv_multiplicativity/#Certifying-Super-Multiplicativity","page":"CV Multiplicativity","title":"Certifying Super-Multiplicativity","text":"","category":"section"},{"location":"cv_multiplicativity/","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"To numerically verify that the communication value of two (or more) channels is super-multiplicative we take the following approach:","category":"page"},{"location":"cv_multiplicativity/","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"Use the dual of pptCV to evaluate an upper bound for textcv(mathcalN).\nUse the seesawCV to evaluate a lower bound for textcv(mathcalNotimesmathcalN).\nSuper-multiplicativity is confirmed if textpptCV(mathcalN textdual)^2  textseesawCV(mathcalNotimesmathcalN).","category":"page"},{"location":"cv_multiplicativity/","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"Since the :dual of pptCV and seesawCV loosely bound the communication value. A confirmation of super-multiplicativity is certain however, false negatives may occur. For channels satisfying textSEP(AB) = textPPT(AB) the pptCV method computes the exact communication value. For this case, we provide the following utility:","category":"page"},{"location":"cv_multiplicativity/","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"pptCVMultiplicativity","category":"page"},{"location":"cv_multiplicativity/#CVChannel.pptCVMultiplicativity","page":"CV Multiplicativity","title":"CVChannel.pptCVMultiplicativity","text":"pptCVMultiplicativity(\n    channel1 :: Choi,\n    channel2 :: Choi;\n    singular_method::Symbol = :primal,\n    parallel_method::Symbol = :dual\n) :: Vector\n\nThis function takes the Choi operators of two channels channel1 (mathcalN_A_1 to B_1) and channel2 (mathcalM_A_2 to B_2) and returns as an array:\n\n[\n    pptCV( channel1 ),\n    pptCV( channel2 ),\n    pptCV( channel1 ⊗ channel2 ),\n    pprt( channel1 ⊗ channel2 ) - pptCV( channel1 ) * pptCV( channel2 )\n]\n\nBy default, it uses pptCVPrimal for the single channel uses, as this provides a lower bound, and pptCVDual for the parallel case, as this is always an upper bound. These defaults can be overridden with the keyword args singular_method and parallel_method which each accept the symbol values :primal and :dual.\n\n\n\n\n\npptCVMultiplicativity(\n        JN :: Matrix,\n        Ndin :: Int,\n        Ndout :: Int,\n        JM :: Matrix,\n        Mdin :: Int,\n        Mdout :: Int;\n        step1isdual = false :: Bool,\n        step2isprimal = false :: Bool\n) :: Vector\n\nThis function takes the Choi operators of two channels mathcalN_A_1 to B_1 and mathcalM_A_2 to B_2 along with their input and output dimensions and returns textpptCV(mathcalN), textpptCV(mathcalM), and textpptCV(mathcalNotimes mathcalM). By default, it uses pptCVPrimal for the single channel values, as this provides a lower bound, and pptCVDual for the parallel case, as this is always an upper bound. If the dimension is such that the dual can't be used, there is an optional argument for using pptCVPrimal. There is also an optional argument to use pptCVDual for single channel values.\n\n\n\n\n\n","category":"function"},{"location":"cv_multiplicativity/#N-Fold-Werner-Holevo-Channel","page":"CV Multiplicativity","title":"N-Fold Werner-Holevo Channel","text":"","category":"section"},{"location":"cv_multiplicativity/","page":"CV Multiplicativity","title":"CV Multiplicativity","text":"wernerHolevoCVPPT\ngeneralWHLPConstraints\nWHIDLP","category":"page"},{"location":"cv_multiplicativity/#CVChannel.wernerHolevoCVPPT","page":"CV Multiplicativity","title":"CVChannel.wernerHolevoCVPPT","text":"wernerHolevoCVPPT(\n    n :: Int64\n    d :: Int64,\n    A :: Matrix{Float64},\n    B :: Matrix{Float64},\n    g :: Matrix{Float64},\n    a :: Matrix{Float64}\n):: Tuple{Float64, Matrix{Float64}}\n\nThis function evaluates the linear program for the PPT relaxation of the communication value of the Werner-Holevo channel. The LP is written\n\n    max langle a v rangle  Ax geq 0  Bx geq 0  langle g  v rangle = 1 \n\nThis function takes as inputs: n, the number of Werner-Holevo channels, d, the dimension of every Werner-Holevo Channel, and the constraints ABga which are obtained from generalWHLPConstraints outputs. It returns the cvPPT value and the optimizer.\n\nwarning: Warning\nFor n geq 10 the solver may be slow.\n\n\n\n\n\n","category":"function"},{"location":"cv_multiplicativity/#CVChannel.generalWHLPConstraints","page":"CV Multiplicativity","title":"CVChannel.generalWHLPConstraints","text":"generalWHLPConstraints(\n    n :: Int,\n    d :: Int,\n    λ_vec :: Union{Vector{Float64},Vector{Int64}}\n) :: Tuple{Matrix{Float64},Matrix{Float64},Matrix{Float64},Matrix{Float64}}\n\nThis function returns the linear program constraints for calculating the PPT communication value of the Werner-Holevo channels run in parallel for arbitrary n. n is the number of Werner-Holevo channels, d is the dimension of every Werner-Holevo channel (assumed to be the same), and lambda_textvec is such that lambda_textveci is the λ parameter for the i^th Werner-Holevo channel. The returned matrices represent the linear maps enforcing the constraints on the optimizer. A is the poistivity constraint, B is the PPT constraint, g is the trace constraint, and a defines the objective function.\n\nSee (need to cite something) for derivation.\n\nwarning: Warning\nIt takes O(n2^2n) steps to generate. If one wants a large dimension, we suggest you save the resulting constraints.\n\n\n\n\n\n","category":"function"},{"location":"cv_multiplicativity/#CVChannel.WHIDLP","page":"CV Multiplicativity","title":"CVChannel.WHIDLP","text":"WHIDLP(\n    d1 :: Int64,\n    d2 :: Int64,\n    λ :: Union{Int,Float64}\n) :: Float64\n\nThis function implements the linear program (LP) to determine the communication value of the Werner-Holevo channel tensored with the identity channel, when the problem is relaxed to optimizing over the PPT cone. (See cite for derivation). d1,d2 are the input-output dimensions of the Werner-Holevo and identity channel respectively. λ is the parameter defining the Werener-Holevo channel.\n\n\n\n\n\n","category":"function"}]
}
