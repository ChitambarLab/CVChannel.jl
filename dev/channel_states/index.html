<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Channels, States, and Operations ¬∑ CVChannel.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ChitambarLab.github.io/cv-channel/channel_states/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CVChannel.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">CV Background</a></li><li><a class="tocitem" href="../communication_value/">CV Optimizations</a></li><li><a class="tocitem" href="../cv_multiplicativity/">CV Multiplicativity</a></li><li><span class="tocitem">Utilities</span><ul><li class="is-active"><a class="tocitem" href>Channels, States, and Operations</a><ul class="internal"><li><a class="tocitem" href="#Channels"><span>Channels</span></a></li><li><a class="tocitem" href="#States"><span>States</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li></ul></li><li><a class="tocitem" href="../optimizer_interface/">Optimization Backends</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Utilities</a></li><li class="is-active"><a href>Channels, States, and Operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Channels, States, and Operations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChitambarLab/cv-channel/blob/master/docs/src/channel_states.md#L" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Channels,-States,-and-Operations"><a class="docs-heading-anchor" href="#Channels,-States,-and-Operations">Channels, States, and Operations</a><a id="Channels,-States,-and-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Channels,-States,-and-Operations" title="Permalink"></a></h1><h2 id="Channels"><a class="docs-heading-anchor" href="#Channels">Channels</a><a id="Channels-1"></a><a class="docs-heading-anchor-permalink" href="#Channels" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CVChannel.Choi" href="#CVChannel.Choi"><code>CVChannel.Choi</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Choi( JN :: AbstractMatrix, in_dim :: Int, out_dim :: Int ) :: Choi{&lt;:Number}

Choi( N :: Function, in_dim :: Int, out_dim :: Int ) :: Choi{ComplexF64}

Choi( kraus_ops :: Vector{&lt;:AbstractMatrix} ) :: Choi{ComplexF64}</code></pre><p>Constructs the Choi matrix representation of a quantum channel. If either a function <code>N</code> or set of kraus operators is provided as input, the Choi matrix is constructed with the <a href="#CVChannel.choi"><code>choi</code></a> method.</p><p>The <code>Choi</code> type contains the fields:</p><ul><li><code>JN :: Matrix{&lt;:Number}</code> - The choi matrix.</li><li><code>in_dim :: Int</code> - The channel&#39;s input dimension.</li><li><code>out_dim :: Int</code> - The Channel&#39;s output dimension.</li></ul><p>A <code>DomainError</code> is thrown if <a href="#CVChannel.is_choi_matrix"><code>is_choi_matrix</code></a> returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL17-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.is_choi_matrix" href="#CVChannel.is_choi_matrix"><code>CVChannel.is_choi_matrix</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_choi_matrix(JN :: AbstractMatrix, dimA :: Int, dimB :: Int) :: Bool</code></pre><p>Returns <code>true</code> if the supplied matrix <code>JN</code> is a Choi operator. This function returns <code>false</code> if</p><ul><li><code>size(JN) != (dimA * dimB, dimA * dimB)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.parChoi" href="#CVChannel.parChoi"><code>CVChannel.parChoi</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parChoi(chan1 :: Choi, chan2 :: Choi) :: Choi</code></pre><p>Returns the tensor product of two <a href="#CVChannel.Choi"><code>Choi</code></a> matrices</p><p class="math-container">\[    J^{AB}_{\mathcal{N}}\otimes J^{A&#39;B&#39;}_{\mathcal{M}} \to
    J^{AA&#39;BB&#39;}_{\mathcal{N}\otimes\mathcal{M}}\]</p><p>where <span>$J^{A:B}_{\mathcal{N}}$</span> and <span>$J^{A&#39;:B&#39;}_{\mathcal{M}}$</span> are the Choi matrices for <code>chan1</code> and <code>chan2</code> respectively. Note the implicit swap between systems <span>$B \leftrightarrow A&#39;$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL64-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.choi" href="#CVChannel.choi"><code>CVChannel.choi</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">choi(ùí© :: Function, Œ£ :: Int, Œõ :: Int) :: Matrix{ComplexF64}
choi(kraus_ops :: Vector{&lt;:AbstractMatrix}) :: Matrix{ComplexF64}</code></pre><p>This function returns the Choi state of a channel represented either as a generic function <code>ùí©</code> or a set of Kraus operators <code>kraus_ops</code>. It does this using that</p><p class="math-container">\[        J_{\mathcal{N}} = \sum_{a,b \in \Sigma} E_{a,b} \otimes \mathcal{N}(E_{a,b}) ,\]</p><p>where <span>$\Sigma$</span> is the finite alphabet indexing the input space and <span>$E_{a,b}$</span> is a square matrix of dimension <span>$\Sigma$</span> with a <span>$1$</span> in the <span>$(a,b)$</span> entry and a <span>$0$</span> everywhere else. The input <span>$\Lambda$</span> is the output dimension. Note this assumes you have a function that calculates <span>$\mathcal{N}(X)$</span> for arbitrary input <span>$X$</span>. As many of the functions for channels in this module have multiple parameters, please note that if you have a channel function <code>ùí©(œÅ, p, q)</code> that calculates <span>$\mathcal{N}_{p,q}(\rho)$</span>, you can declare a function <code>ùí©_xy(œÅ) = ùí©(œÅ,x,y)</code> for fixed <code>(x,y)</code> and then call, <code>choi(ùí©_xy, Œ£)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL87-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.isometricChannel" href="#CVChannel.isometricChannel"><code>CVChannel.isometricChannel</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isometricChannel(kraus_ops :: Vector) :: Matrix</code></pre><p>This function builds the isometric representation <span>$V$</span> of a channel <span>$\mathcal{N}: A \to B$</span> from the Kraus operators <span>$\{K_{i}\}$</span>. It does this by calculating</p><p class="math-container">\[    V = \sum_{i} K_{i} \otimes |i\rangle\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL129-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.complementaryChannel" href="#CVChannel.complementaryChannel"><code>CVChannel.complementaryChannel</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complementaryChannel(kraus_ops :: Vector) :: Vector</code></pre><p>This function takes a set of Kraus operators for a channel <span>$\mathcal{N}_{A \to B}$</span> and returns a set of Kraus operators for the complementary channel, <span>$\mathcal{N}^{c}_{A \to E}$</span>. It does this by generating the Kraus operators of the isometric representation of the channel followed by partial trace on the <span>$B$</span> space.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If <span>$\mathcal{N}_{A \to B}$</span> is already isometric, the code lets dimE=2 so that functions are well behaved.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL153-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.krausAction" href="#CVChannel.krausAction"><code>CVChannel.krausAction</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">krausAction(kraus_ops :: Vector, X)</code></pre><p>This function takes a set of Kraus operators for a channel <span>$\mathcal{N}_{A \to B}$</span> and returns the output of the channel for input <span>$X$</span>. That is, given input <span>$X$</span> it returns</p><p class="math-container">\[    \mathcal{N}_{A \to B}(X) = \sum_{i} K_{i} X K_{i}^{\ast}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL192-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.depolarizingChannel" href="#CVChannel.depolarizingChannel"><code>CVChannel.depolarizingChannel</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">depolarizingChannel(œÅ :: Matrix{Float64}, q :: Union{Int,Float64}) :: Matrix{ComplexF64}</code></pre><p>This calculates the action of the depolarizing channel,</p><p class="math-container">\[\Delta_{q}(\rho) = (1-q)\rho + q \text{Tr}(\rho) \frac{1}{d} I_{AB} ,\]</p><p>where <span>$q \in [0,1].$</span> Note these channels are the channels covariant with respect to the unitary group.</p><p>A <code>DomainError</code> is thrown if:</p><ul><li>Matrix <code>œÅ</code> is not square</li><li>Input <code>q</code> does not satisfy <code>0 ‚â§ q ‚â§ 1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL211-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.dephrasureChannel" href="#CVChannel.dephrasureChannel"><code>CVChannel.dephrasureChannel</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dephrasureChannel(
    œÅ :: Matrix{&lt;:Number},
    p :: Union{Int,Float64},
    q :: Union{Int,Float64}
) :: Matrix{ComplexF64}</code></pre><p>This function calculates the action of the <a href="https://arxiv.org/abs/1806.08327">dephrasureChannel</a>,</p><p class="math-container">\[\mathcal{N}_{p,q}( \rho) := (1-q)((1-p) \rho + pZ \rho Z) + q \text{Tr}( \rho) |e\rangle \langle e|,\]</p><p>where <span>$p,q \in [0,1]$</span>, <span>$Z$</span> is the Pauli-Z matrix, and <span>$|e\rangle\langle e|$</span> an  error  flag orthogonal to the  Hilbert space of input state <span>$\rho$</span>.</p><p>A <code>DomainError</code> is thrown if:</p><ul><li>Matrix <code>œÅ</code> is not <code>2x2</code></li><li>Inputs <code>p</code> or <code>q</code> do not satisdy <code>0 ‚â§ p,q ‚â§ 1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL238-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.wernerHolevoChannel" href="#CVChannel.wernerHolevoChannel"><code>CVChannel.wernerHolevoChannel</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wernerHolevoChannel(œÅ :: Matrix{&lt;:Number}, Œª :: Union{Int,Float64}) :: Matrix{ComplexF64}</code></pre><p>This function calculates the action of the <a href="https://arxiv.org/abs/1406.7142">generalized Werner-Holevo channels</a></p><p class="math-container">\[    \mathcal{W}_{d,\lambda}(\rho) = \lambda \Phi_{0}(œÅ) + (1-\lambda) \Phi_{1}(œÅ)\]</p><p>where <span>$\lambda \in [0,1]$</span>. This means these are convex combinations of the original <a href="https://arxiv.org/abs/quant-ph/0203003">Werner-Holevo channels</a> which are defined as</p><p class="math-container">\[    \Phi_{0}(œÅ) = \frac{1}{d+1}(\text{Tr}[\rho]I_{d} +œÅ^{T}) \hspace{1cm}
    \Phi_{1}(œÅ) = \frac{1}{d-1}(\text{Tr}[\rho]I_{d} -œÅ^{T}) .\]</p><p>Note the Choi matrices of these generalized channels are the (unnormalized) Werner states.</p><p>A <code>DomainError</code> is thrown if:</p><ul><li>Matrix <code>œÅ</code> is not square</li><li><code>p</code> is not in  range <code>0 ‚â§ p ‚â§ 1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL273-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.siddhuChannel" href="#CVChannel.siddhuChannel"><code>CVChannel.siddhuChannel</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">siddhuChannel(œÅ :: Matrix{&lt;:Number}, s :: Union{Int,Float64}) :: Matrix{&lt;:Number}</code></pre><p>This function calculates the action of the Siddhu channel <span>$N_{s}$</span> which is defined by Kraus operators:</p><p class="math-container">\[    \begin{aligned}
    K_{0} = \begin{bmatrix} \sqrt{s} &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \end{bmatrix}
    \hspace{5mm}
    K_{1} = \begin{bmatrix} 0 &amp; 0 &amp; 0 \\ \sqrt{1-s} &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} ,
    \end{aligned}\]</p><p>where <span>$s \in [0,1/2]$</span>. This channel was introduced in Equation 9 of <a href="https://arxiv.org/abs/2003.10367">this paper</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL308-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.generalizedSiddhu" href="#CVChannel.generalizedSiddhu"><code>CVChannel.generalizedSiddhu</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generalizedSiddhu(
      œÅ :: Matrix{&lt;:Number},
      s :: Union{Int,Float64},
      Œº :: Union{Int,Float64}
) :: Matrix{&lt;:Number}</code></pre><p>This function calculates the action of the generalized Siddhu channel <span>$\mathcal{N}_{s,\mu}$</span> on the qutrit state <span>$\rho$</span>. The action of the channel is defined by Kraus operators:</p><p class="math-container">\[    \begin{aligned}
    K_{0} = \begin{bmatrix}
                \sqrt{s} &amp; 0 &amp; 0 \\
                0 &amp; \sqrt{1-\mu} &amp; 0 \\
                0 &amp; 0 &amp; \sqrt{\mu}
             \end{bmatrix}
    \hspace{5mm}
    K_{1} = \begin{bmatrix}
                0 &amp; 0 &amp; \sqrt{1-\mu} \\
                \sqrt{1-s} &amp; 0 &amp; 0 \\
                0 &amp; \sqrt{\mu} &amp; 0
            \end{bmatrix} ,
    \end{aligned}\]</p><p>where <span>$s \in [0,1/2]$</span>, <span>$\mu \in [0,1]$</span>. This channel was introduced by Leditzky <em>et al.</em> (cite when on arxiv).</p><p>A <code>DomainError</code> is thrown if:</p><ul><li>Matrix <code>œÅ</code> is not square</li><li><code>œÅ</code> is not a 3-dimensional matrix</li><li><code>s</code> is not in range <code>0 ‚â§ s ‚â§ 1/2</code></li><li><code>Œº</code> is not in range <code>0 ‚â§ Œº ‚â§ 1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL336-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.GADChannel" href="#CVChannel.GADChannel"><code>CVChannel.GADChannel</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">GADChannel(
    œÅ :: Matrix{&lt;:Number},
    p :: Union{Int,Float64},
    n :: Union{Int,Float64}
) :: Matrix{&lt;:Number}</code></pre><p>This function calculates the action of the generalized (qubit) amplitude damping channel <span>$\mathcal{A}_{p,n}$</span> which is defined by Kraus operators:</p><p class="math-container">\[    \begin{aligned}
    K_{0} =&amp; \sqrt{1-n} \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; \sqrt{1-p} \end{bmatrix}
    \hspace{5mm}
    K_{1} =&amp; \sqrt{p(1-n)} \begin{bmatrix} 0 &amp; 1 \\ 0 &amp; 0 \end{bmatrix}  \\
    K_{2} =&amp; \sqrt{n} \begin{bmatrix} \sqrt{1-p} &amp; 0 \\ 0 &amp; 1 \end{bmatrix}
    \hspace{5mm}
    K_{3} =&amp; \sqrt{pn} \begin{bmatrix} 0 &amp; 0 \\ 1 &amp; 0 \end{bmatrix}
    \end{aligned}\]</p><p>where <span>$p,n \in [0,1]$</span>. This channel may be found in Section 3 of <a href="https://arxiv.org/abs/2107.13486">this paper</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/channels.jl#LL386-L407">source</a></section></article><h2 id="States"><a class="docs-heading-anchor" href="#States">States</a><a id="States-1"></a><a class="docs-heading-anchor-permalink" href="#States" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CVChannel.wernerState" href="#CVChannel.wernerState"><code>CVChannel.wernerState</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wernerState(dim :: Int, p ::Union{Int,Float64}) :: Matrix{Float64}</code></pre><p>This function constructs the Werner states,</p><p class="math-container">\[    \sigma_{d,p} = p \frac{\Pi_{0}}{d+1 \choose 2} + (1-p) \frac{\Pi_{1}}{d \choose 2}\]</p><p>where <span>$p \in [0,1]$</span> and <span>$\Pi_0, \Pi_1$</span> are the projectors onto the symmetric and anti-symmetric subspaces respectively. They can be determined by</p><p class="math-container">\[    \Pi_0 = \frac{1}{2} (I_{A} \otimes I_{B} + \mathbb{F}) \hspace{1cm} \Pi_1 = \frac{1}{2}(I_{A} \otimes I_{B} - \mathbb{F})\]</p><p>where <span>$\mathbb{F}$</span> is the swap operator.</p><p>A <code>DomainError</code> is thrown if:</p><ul><li><code>d ‚â§ 1</code></li><li><code>p</code> is not in range <code>0 ‚â§ p ‚â§ 1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/states.jl#LL1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.axisymmetricState" href="#CVChannel.axisymmetricState"><code>CVChannel.axisymmetricState</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">axisymmetricState(
    d :: Int64,
    x :: Union{Int,Float64},
    y :: Union{Int,Float64}
) :: Matrix{Float64}</code></pre><p>Construct the axisymmetric state <span>$\rho^{\text{axi}}$</span> as described in section IV.C. of <a href="https://arxiv.org/pdf/1505.01833.pdf">this paper</a>. This state is a bipartite quantum state with each subspace having dimension <code>d</code>. The diagonal of <span>$\rho^{\text{axi}}$</span> is parameterized as</p><p class="math-container">\[    \rho^{\text{axi}}_{jj,jj} = \frac{1}{d^2}+a, \quad \text{and}\quad \rho^{\text{axi}}_{jk,jk} = \frac{1}{d^2}- \frac{a}{d-1} \; (j\neq k)\]</p><p>while the off-diagonals are expressed as</p><p class="math-container">\[    \rho^{\text{axi}}_{jj,kk} = b,\]</p><p>where <span>$a = y\frac{d-1}{d}$</span> and <span>$b = \frac{x}{\sqrt{d(d-1)}}$</span>. All remaining elements of <span>$\rho^{\text{axi}}$</span> are zero. Inputs <code>x</code> and <code>y</code> of the <code>axisymmetricState</code> function parameterize <span>$\rho^{\text{axi}}$</span> and are constrained as:</p><ul><li><span>$-\frac{1}{d\sqrt{d-1}} \leq y \leq \frac{\sqrt{d-1}}{d}$</span></li><li><span>$-\frac{1}{\sqrt{d(d-1)}}\leq x \leq \sqrt{\frac{d-1}{d}}$</span></li><li><span>$-\frac{1}{\sqrt{d}}\left( y + \frac{1}{d\sqrt{d-1}}\right) \leq x \leq \frac{d-1}{\sqrt{d}}\left(y + \frac{1}{d\sqrt{d-1}} \right)$</span></li></ul><p>If any of the constraints above do not hold, a <code>DomainError</code> is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/states.jl#LL31-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.haarStates" href="#CVChannel.haarStates"><code>CVChannel.haarStates</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">haarStates(n :: Int64, d :: Int64) :: Vector{Matrix{ComplexF64}}</code></pre><p>Constructs a list of <code>n</code> random states on a <code>d</code>-dimensional Hilbert space according to the Haar measure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/states.jl#LL116-L121">source</a></section></article><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CVChannel.isPPT" href="#CVChannel.isPPT"><code>CVChannel.isPPT</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isPPT(x, sys :: Int, dims :: Vector) :: Bool</code></pre><p>This function returns true if the input state x is PPT with respect to the (sys)th system. False otherwise. dims is a vector of the sizes of the subsystems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/operations.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.swapOperator" href="#CVChannel.swapOperator"><code>CVChannel.swapOperator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swapOperator(dim :: Int) :: Matrix{Float64}</code></pre><p>This function is the swap operator <span>$\mathbb{F}$</span> which is defined by the action</p><p class="math-container">\[\mathbb{F}(u \otimes v) = v \otimes u \hspace{5mm} u,v \in \mathcal{H}_{A} .\]</p><p>The function uses that <span>$\mathbb{F} = \sum_{a,b \in \Sigma} E_{a,b} \otimes E_{b,a}$</span> where <span>$E_{a,b}$</span> is a square matrix of dimension <span>$\Sigma$</span> with a one in the <span>$(a,b)$</span> entry and a <span>$0$</span> everywhere else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/operations.jl#LL23-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.permuteSubsystems" href="#CVChannel.permuteSubsystems"><code>CVChannel.permuteSubsystems</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permuteSubsystems(
    œÅ:: Vector,
    perm::Vector{Int64},
    dims::Vector{Int64}
) :: Vector</code></pre><p>This function returns the vector with the subsystems permuted. For example, given three subspaces <span>$A,B,C$</span>, and the permutation <span>$\pi$</span> defined by <span>$(A,B,C) \xrightarrow[]{\pi} (C,A,B),$</span> the function implements the process:</p><p class="math-container">\[    |e_{i}\rangle_{A} |e_j \rangle_{B} |e_k \rangle_{C} \xrightarrow[]{\pi}
    |e_{k} \rangle_{C} |e_{i}\rangle_{A}  |e_{j} \rangle_{B}  ,\]</p><p>by re-indexing the vector, permuting the indices appropriately, and converting it back into a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/operations.jl#LL50-L66">source</a></section><section><div><pre><code class="nohighlight hljs">permuteSubsystems(
    œÅ:: Matrix,
    perm::Vector{Int64},
    dims::Vector{Int64}
) :: Matrix</code></pre><p>This function returns the matrix with the subsystems permuted. It is a generalization of the vector code. For example, given three subspaces <span>$A,B,C$</span>, and the permutation <span>$\pi$</span> defined by <span>$(A,B,C) \xrightarrow[]{\pi} (C,A,B),$</span> the function implements the process:</p><p class="math-container">\[|e_{i}\rangle\langle e_{i}|_{A}\otimes |e_j \rangle\langle e_j|_{B}\otimes |e_k \rangle\langle e_k|_{C} \xrightarrow[]{\pi}
|e_{k} \rangle\langle e_{k}|_{C}\otimes |e_{i}\rangle\langle e_{i}|_{A} \otimes  |e_{j} \rangle\langle e_{j}|_{B} ,\]</p><p>by re-indexing the matrix, permuting the indices, and reconstructing the matrix. Both bra and ket indices receive the same permutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/operations.jl#LL77-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.shiftOperator" href="#CVChannel.shiftOperator"><code>CVChannel.shiftOperator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shiftOperator(d::Int64) :: Matrix</code></pre><p>This function returns the operator that shifts the computational basis mod d for complex Euclidean space of dimension d. That is, it returns the operator <span>$S$</span> defined by the action</p><p class="math-container">\[    S|k\rangle = |k+1 \mod d \rangle\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/operations.jl#LL111-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CVChannel.discreteWeylOperator" href="#CVChannel.discreteWeylOperator"><code>CVChannel.discreteWeylOperator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">discreteWeylOperator(m :: Int64, n :: Int64, d :: Int64)</code></pre><p>This function returns the (m,n)^th unitary for generating the generalized Bell basis. They are defined by their action on the computational basis:</p><p class="math-container">\[    U_{m,n}|e_{k}\rangle = e^{2 \pi mk i / d} |e_{k+n}\rangle\]</p><p>These are the discrete Weyl Operator basis. See <a href="https://arxiv.org/abs/1004.1655">Section 3 of this paper</a> for further details.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Different works define the discrete Weyl operators differently such that the phase or ordering may differ. Please check your reference.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChitambarLab/cv-channel/blob/25021d046ba7d41bc25a2baf248b4c7005242ce7/src/operations.jl#LL128-L141">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../cv_multiplicativity/">¬´ CV Multiplicativity</a><a class="docs-footer-nextpage" href="../optimizer_interface/">Optimization Backends ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Monday 20 September 2021 18:04">Monday 20 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
